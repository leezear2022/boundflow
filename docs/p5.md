下面这份是我按**你当前 Phase4 现状（Task pipeline / StoragePlan / LinearSpec(C) / permute 语义补齐）+ 你已转向 TVM Relax（不再走 TE 主线）**重新写的 **Phase 5 科研计划 + 工程计划**。工程计划里我会把“可能的算法创新点”都做成**可插拔接口/Pass**，这样你可以先把系统跑起来、论文思路再慢慢收敛。

另外，“能不能扫到你 repo 最新改动”这件事：我这边用网页检索没拿到 `leezear2022/boundflow` 的公开页面（大概率是仓库私有或抓取受限），所以**无法可靠按最新 commit diff 来逐行对齐**；我只能基于你在对话里描述的结构与变更来设计 Phase5。如果你希望我真正做到“按你最新代码命名/文件路径精确对齐”，最稳的是你把 repo 打包/或贴 `git diff --stat` + `tree boundflow -L 3`。

---

## Phase 5 的科研主线（Planner 是核心创新，但要“系统化”）

### 研究问题（ASPLOS口径）

把 LiRPA/验证当成一等工作负载后，瓶颈往往不是单个算子数学，而是：

* **重计算**（同一个中间 bound 在不同 method/spec/BaB node 反复算）
* **kernel碎片化与launch开销**（Python驱动、小kernel多、同步多）
* **layout/transpose 等“非数学”开销**（验证图里异常常见）
* **内存峰值与复用不足**（bound tensor 比 forward tensor 更大、更成对）

auto_LiRPA 的 `compute_bounds` 把 `C`、`method`、`reuse_ibp`、`reuse_alpha`、`cache_bounds` 等参数都暴露出来，本质上就是在告诉你：**“调度/复用/缓存”是 verifier 的第一类语义**。
α,β-CROWN 更进一步，把 BaB 的 split constraints 变成可优化参数并强调 GPU 可并行的 bound propagation。

> 所以 Phase5 的“Planner 创新”不应只是一套硬编码 heuristic，而应是：**把“验证语义”显式编码进 IR + Planner Pass pipeline，形成可插拔的优化空间**。

---

## Phase 5 你应该预留的“潜在算法创新接口”（不要求你现在就定最终idea）

我建议把 Planner 的创新点预留为 6 类“pass slots”，先做 baseline，再逐步启用更激进的策略：

1. **Spec/Property Folding Pass（你已经做了 last-linear 的 C 融合）**

   * Phase5 扩展：不止最后一层，允许把线性 spec 向前吸收/重排（在不改变语义的前提下，减少松弛或减少算子数）。
   * 接口：`property_rewrite(program, spec) -> (program’, spec’)`（可多策略对比）

2. **Domain Mix Pass（IBP / CROWN-IBP / backward / 未来 zonotope 等）**

   * 类似 auto_LiRPA “CROWN-IBP”组合思想，但让 Planner 选择“哪些层/哪些 region 用哪种 domain”。
   * 接口：`assign_domain(region) -> DomainKind`，并允许以后加入 DeepPoly/Zono/MIP/SMT

3. **Task Partition & Fusion Pass（减少 kernel launch + 提高算子密度）**

   * 粗粒度：按 region 切 task（你 Phase4 是整图1个task）
   * 细粒度：把“lower/upper成对计算”做成**单 kernel**（interval conv/linear 同时算上下界），并提供 fuse 规则接口

4. **Cache/Reuse Pass（把 reuse_ibp/cache_bounds 变成系统级优化）**

   * Phase5 核心：让 cache key 显式依赖 (task_id, domain, spec_id, eps, split_state, layout…)
   * 接口：`CachePlan` + `ReusePolicy`（后续可用于 BaB 节点批处理）

5. **Layout/Transpose Pass（把 permute 当可移动/可消对象）**

   * 你 Phase4 做了语义正确执行；Phase5 做“消/下推/合并”，把 layout 变成 planner 的优化维度（这对 TVM lowering 和 kernel fusion 都关键）

6. **Cost Model / Search Hook（可发论文的“Planner算法”载体）**

   * baseline：规则+贪心
   * 升级：基于 profiling 的代价模型 + 小规模搜索（beam / ILP / CP-SAT / MCTS 都可以挂接）
   * 接口：`PlannerObjective`（time/memory/tightness 的多目标权衡）

---

## Relax 取代 TE：Phase 5 的后端策略（与你当前选择一致）

你已经决定以 Relax 为主线是合理的：Relax 官方路径就是把高层 op **Legalize** 成 `call_tir` 的 mixed IRModule，并且支持用户用自定义 map 覆盖 legalization。
另外 Relax 的 `R.call_tir` 与结构信息（TensorStructInfo）就是你做“验证图 + bound tensor shape/dtype”对齐的天然载体。

> 关键点：**BoundFlow 的“bound kernels”不要走 TE schedule；直接产出 TIR PrimFunc（TVMScript/TIR schedule），再由 Relax 包装 call_tir 调用。**（LegalizeOps 只是其中一条路；你也可以“自己生成 mixed module”跳过 TE。）

---

# Phase 5 工程计划（带科研接口预留）

我把 Phase5 拆成 5A–5F。每个阶段都有：代码模块、接口、baseline实现、预留创新slot、DoD。

---

## 5A：Planner v1 变成“Pass Pipeline”，输出 TaskGraph + Plan Bundle

**目标**：从 `plan_interval_ibp_v0(program)-> BFTaskModule` 升级为：

* `plan(program, spec, config) -> PlanBundle`
* PlanBundle 至少包含：

  * `task_graph`（多 task DAG）
  * `storage_plan`（可复用/生命周期）
  * `cache_plan`（可选）
  * `layout_plan`（可选）
  * `lowering_plan`（python/tvm fallback策略）

**新增/调整文件（建议）**

* `boundflow/planner/core.py`

  * `PlannerConfig`, `PlannerPass`, `PlannerContext`, `PlanBundle`
* `boundflow/ir/task_graph.py`

  * DAG + edge（buffer依赖）+ topo sort + validate
* `boundflow/planner/passes/`

  * `normalize_pass.py`（复用你前端normalize成果）
  * `partition_pass.py`（baseline：按 permute/spec 边界切 region）
  * `domain_assign_pass.py`（baseline：全部 interval；预留 mix）
  * `storage_pass.py`（先生成 v0 storage，再交给 5B 优化）
  * `lowering_select_pass.py`（先全部 python，后面 5E 开 tvm）

**DoD**

* Planner v1 输出 task_graph 后，现有 Phase4 测试（MLP/CNN IBP + C-spec 对齐）全部过
* 新增测试：`planner_v0(single task)` vs `planner_v1(multi task)` 输出一致

---

## 5B：StoragePlan v1：liveness + reuse（内存是系统论文硬指标）

**baseline**：做 liveness（last_use），在 shape/dtype 相同的 buffer 上做复用（greedy）。

**新增文件**

* `boundflow/planner/passes/liveness_pass.py`
* `boundflow/planner/passes/buffer_reuse_pass.py`
* （可选）`boundflow/runtime/memory_arena.py`：后续 TVM runtime/自定义 allocator 可用

**预留创新接口**

* `ReusePolicy`：允许以后加入“跨task复用”“inplace规则”“split_state-aware reuse”
* `Objective(memory_peak)`：多目标优化入口（和 5F cost model 统一）

**DoD**

* 给同一 CNN：峰值 bytes 或 buffer 数明显下降（哪怕 20%）
* 输出不变（与 python reference 对齐）

---

## 5C：CachePlan / Reuse 语义对齐 auto_LiRPA 参数（为 BaB/训练打地基）

auto_LiRPA 的 `compute_bounds` 明确支持 `reuse_ibp`, `reuse_alpha`, `cache_bounds`。
Phase5 要把它升级成系统机制，而不是“某个函数里 if cache”。

**新增/调整**

* `boundflow/ir/cache_plan.py`

  * `CacheScope`（RUN_LOCAL / EPOCH / PERSISTENT）
  * `CacheKeySchema`（规范化 key）
* `boundflow/runtime/cache.py`

  * `BoundCache.get/put/stats`
* 执行器统一入口：

  * `executor.run(plan_bundle, input_spec, *, reuse_ibp=False, reuse_alpha=False, cache_bounds=False, ...)`

**预留创新接口**

* `CachePolicy`：支持“tightness-aware cache”（只缓存足够紧的中间界）
* `BatchingPolicy`：未来把多个 spec / 多个 BaB node 合并成 batch

**DoD**

* 重复运行同一输入：cache hit 可观测且速度提升
* 与 auto_LiRPA 行为对齐（至少语义层面：reuse开关不改变正确性）

---

## 5D：最小 CROWN-IBP / backward LiRPA 主流程闭环（Bound IR 入主线）

这一步是为“Planner创新”提供第二个 domain，才能玩 **domain mix / selective tightening**。

**新增/调整**

* `boundflow/ir/bound.py`：从占位变主流程
* `boundflow/domains/linear.py`：线性界表示（A,b 或等价）
* `boundflow/planner/passes/domain_assign_pass.py`：先支持两种：

  * interval
  * crown_ibp（中间 interval，输出/部分层 backward tightening）
* `boundflow/runtime/task_executor.py`：先 python 实现 linear-domain 执行（TVM 在 5E 再做）

**与现有生态对齐**

* auto_LiRPA method 包含 `IBP`、`CROWN-IBP`、`backward` 等（你可以先对齐一条稳定路径）。

**DoD**

* 在 MLP + 小 CNN：CROWN-IBP bounds 不劣于 IBP
* 对齐/对照 auto_LiRPA（误差允许范围内）

---

## 5E：Relax 后端：Bound Kernels → TIR PrimFunc → Relax call_tir（不走 TE）

**核心依据**：Relax 的 LegalizeOps 会把 Relax op 变成 `call_tir`，并支持自定义 legalization map。
你可以两种路线二选一（工程上我建议 A）：

### 路线 A（推荐）：BoundFlow 自己生成 mixed IRModule

* 你不必把 bound op “伪装成 relax.nn.conv2d”；直接：

  1. 为每个 TaskOp 生成一个 TIR PrimFunc（TVMScript）
  2. 再生成一个 Relax wrapper function：`R.call_tir(primfunc, args, out_sinfo)`
* 这样完全绕开 TE。

### 路线 B：把某些 bound op 映射到 Relax op，再用 LegalizeOps customize map 接管

* 适合后续想吃 TVM 的 FuseOps/FuseTIR pipeline 的场景，但工程复杂度更高。

**新增文件**

* `boundflow/backends/relax/ir_builder.py`

  * `emit_primfunc_interval_linear/conv2d/relu/...`
  * `emit_relax_wrapper(task)`
* `boundflow/runtime/relax_executor.py`

  * compile / run / module cache
* （可选）用 Relax pipeline “zero” 做基础图优化与融合：LegalizeOps、AnnotateTIROpPattern、FuseOps 等（官方教程里有）。

**预留创新接口**

* `LoweringStrategy`: python / relax(tir) / relax(fused) / extern-packed
* `ScheduleHint`: 给 TIR schedule 或 meta-schedule 的 hint
* `LayoutHint`: 与 5A/5B 的 layout_plan 对接

**DoD**

* 同一 PlanBundle：PythonExecutor 与 RelaxExecutor 输出一致
* 有一个 benchmark 脚本展示端到端加速（哪怕先 1.5×，闭环更重要）

---

## 5F：Planner 的“科研优化空间”落到代码：Cost model + Search + Ablation Harness

这一步是 Phase5 论文/科研最关键的“实验平台”，不要求你一次做出最终最强算法，但必须把**接口与可复现实验框架**做出来。

**新增**

* `boundflow/planner/objectives.py`

  * `Objective = w1*time + w2*peak_mem + w3*tightness + w4*compiletime`
* `boundflow/planner/search/`

  * `greedy_search.py`（baseline）
  * `beam_search.py`（可选）
  * 预留：`cp_sat_search.py`（你未来要接 CPIM/CSP）
* `boundflow/benchmarks/planner_ablation.py`

  * 一次跑 N 个 planner config（domain mix / partition granularity / cache on/off / layout pass on/off）
  * 输出 CSV（time, peak_mem, bound tightness, #kernels, compile_time）

**tightness 指标建议**

* verified margin / certified accuracy（你已有 LinearSpec(C)）
* 与 auto_LiRPA 对照（同输入 eps 下的 bound 差距）

**DoD**

* 任何一个 pass 的 on/off 都能自动 ablate，并产出可画图的数据
* 给 ASPLOS 论文准备“系统式消融图”（launch数/峰值内存/吞吐/紧致度）

---

# Phase 5 里程碑顺序（建议 6 个 PR）

1. PR1：5A（Planner pipeline + TaskGraph + PlanBundle）
2. PR2：5B（liveness + reuse）
3. PR3：5C（cache plan + reuse API）
4. PR4：5E（RelaxExecutor v0：interval kernels 先覆盖 linear/conv2d/relu）
5. PR5：5D（最小 CROWN-IBP 主流程）
6. PR6：5F（cost/search/ablation harness）

---

## Phase 5 与 Phase 6（BaB）如何“接口对齐而不提前开工”

β-CROWN/α,β-CROWN 证明：BaB 的关键是**批量化 bound propagation + 复用 + 把 split constraints 编码进 bound 过程**。
所以 Phase5 只要把这些钩子留好：

* `SplitState`/`ConstraintStore` 作为 cache key 的一部分（先占位）
* `BatchingPolicy` 支持 “multi-spec batch”（先做）→ “multi-node batch”（后做）

---

## 你现在可以立刻落地的“Phase5 论文角度贡献草案”

（先给你一个不依赖最终最强算法的写法）

* **系统抽象贡献**：把 `compute_bounds` 类 verifier API 的复用/缓存/性质表达（C矩阵）显式建模为 Planner/PlanBundle（对齐 auto_LiRPA 语义）。
* **编译后端贡献**：基于 Relax 的 `call_tir` mixed module 生成 bound kernels，提供可替换 executor，并可用官方 pipeline 做基础融合/优化。
* **优化空间贡献**：提出并实现一组 verifier-aware planner passes（partition/domain/layout/cache/memory），并用 ablation harness 系统化评估（time/mem/tightness）。
* **向完整验证扩展路径**：接口级兼容 BaB（α,β-CROWN 类路径），而 Phase5 先不实现完全 BaB。

---

如果你愿意，我可以把这份 Phase5 计划**改写成你 repo 里的 `docs/phase5_research_and_engineering_plan.md` 格式**（含：模块图、每个 pass 的输入输出、每个 PR 的文件清单、每个 DoD 的 pytest 名称），你直接丢给另一个模型“照文档生成代码”就行。
